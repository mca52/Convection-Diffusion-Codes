
load "Element_Mixte"
mesh Th=square(100,100); 
fespace Vh(Th,P1); 
Vh uold,vold;
real ep=1e-6;
real kappa1,kappa2,kappa3;
real dt=1e-5;
real t=0;
//func b1=cos(x)*sin(y);
//func b2=-sin(x)*cos(y);
//real b1=2;
//real b2=3;
real b1=1;
real b2=0;
real c=0;

func g=(2/(pi^2*ep))*(x-1/(pi^2*ep))*cos(pi*y);
func dyyg=-(2/ep)*(x-1/(pi^2*ep))*cos(pi*y);
func dxxg=0;
func dxg=(2*cos(pi*y))/(pi^2*ep);
func dyg=-(2*(x-1/(pi^2*ep))*sin(pi*y))/(pi*ep);
func f=-ep*(dyyg+dxxg)+1*dxg+0*dyg+c*g;


//func dxg =-sin(x+y);
//func dyg =-sin(x+y);
//func dyyg=-cos(x+y);
//func dxxg=-cos(x+y);
kappa1=ep/2.;
kappa2=(sqrt(2)*kappa1*(dt)^2)/(8*pi);
//kappa2=(dt)^2*(ep/4)*(sqrt(2)/pi);
//kappa2=1e-11;
kappa3=1;

// Computing the first approximation - Poisson problem
solve Poisson(uold,vold)=
      int2d(Th)(0.01*(dx(uold)*dx(vold)+dy(uold)*dy(vold)))
      +int2d(Th)((b1*dx(uold)+b2*dy(uold))*vold)
      +int2d(Th)(c*uold*vold)
      -int2d(Th)(f*vold)
      +on(1,2,3,4,uold=g);

fespace Vh1(Th,P2);
Vh1 v,u,un,error;
un=uold;
fespace Rh(Th,RT1);
Rh [sigma1,sigma2];
Rh [sigman1,sigman2];
Rh [tau1,tau2];
Rh [sigerr,sigdiverr];
macro sigma[sigma1,sigma2]//
macro sigman[sigman1,sigman2]//
macro grad(u) [dx(u),dy(u)]//
macro tau[tau1,tau2]//
macro div(sigma)[dx(sigma1)+dy(sigma2)]//
macro divg(tau)[dx(tau1)+dy(tau2)]//
solve ad([sigma1,sigma2,u],[tau1,tau2,v])
               =int2d(Th)(dt*(sigma'*tau)/ep)
               -int2d(Th)(dt*u*(dx(tau1)+dy(tau2)))
               +int2d(Th)(dt*v*(dx(sigma1)+dy(sigma2)))
               +int2d(Th)((1+dt*c)*u*v)
               -int2d(Th)(convect([b1,b2],-dt,un)*v)
               +int2d(Th)(kappa1*dt*(sigma'*grad(v)/ep-(sigma'*tau)/(ep^2)+grad(u)'*grad(v)-tau'*grad(u)/ep))
               +int2d(Th)(kappa2*(dt*div(sigma)'*divg(tau)+dx(tau1)*(u+u*dt*c)+dy(tau2)*(u+u*dt*c)))
               -int2d(Th)(kappa2*(dx(tau1)*convect([b1,b2],-dt,un)+dy(tau2)*convect([b1,b2],-dt,un)))
               +int1d(Th)(kappa3*u*v) // when c=0
               -int2d(Th)(dt*f*v)
               +int1d(Th)(dt*g*(N.x*tau1+N.y*tau2))
               -int2d(Th)(kappa2*f*dt*(dx(tau1)+dy(tau2)))
               -int1d(Th)(kappa3*g*v); // when c=0
int n=20;
real[int] H1a(n),L2a(n),H11a(n),erra(n);
sigman=sigma;//initializing sigma^n-1 as sigma^1
un=u;
for(n=1;n<20;n=n+1){
       
       ad;
       error=u-un;// So, here u^n=u^2 from the second iteration and u^n-1=u^1
       L2a[n]=sqrt(int2d(Th)(u-un)^2);
       H1a[n]=sqrt(int2d(Th)((error)^2)+int2d(Th)((dx(u)-dx(un))^2)+int2d(Th)((dy(u)-dy(un))^2));
       //H1a[n]=sqrt(int2d(Th)((dy(u)-dy(un))^2));
       H11a[n]=sqrt(int2d(Th)((sigman1-sigma1)^2)+int2d(Th)((sigman2-sigma2)^2)+int2d(Th)((dx(sigman1)-dx(sigma1)+dy(sigman2)-dy(sigma2))^2));
       
       //H11a[n]=sqrt(int2d(Th)((-ep*dx(un)-sigma1)^2)+int2d(Th)((-ep*dy(un)-sigma2)^2)+int2d(Th)((f-b1*dx(un)+c*u-dx(sigma1))^2)+int2d(Th)((f-b2*dy(un)+c*u-dy(sigma2))^2));
       //H11a[n]=sqrt(int2d(Th)((-ep*dx(u)-sigma1)^2)+int2d(Th)((-ep*dy(u)-sigma2)^2)+int2d(Th)((-ep*dxx(u)-dx(sigma1)-ep*dyy(u)-dy(sigma2))^2));
       erra[n]=sqrt(H1a[n]^2+H11a[n]^2);
       
       cout<<n<<"tot err="<<erra[n]<<endl;
       if (erra[n]<=0.1)
        {
       break;
       }
       un=u; //Swapping values of u^n-1 with u^n
       sigman=sigma; //Swapping values of u^n-1 with u^n
       
       }



varf indicator2 (unused, chiK)
= int2d(Th)((dt^3*ep/16)*chiK*(square(hTriangle)+square(kappa2))*square(dt*f -dt*(dx(sigma1) + dy(sigma2))-(1+dt*c)*u+convect([b1,b2],-dt,un)))
 +int2d(Th)((dt^3*ep/16)*chiK*dt^2*(kappa1^2+(1+square(hTriangle))*square(1-kappa1/ep))*(square(dx(u)+sigma1/ep)+square(dy(u)+sigma2/ep)))
 +int1d(Th)((dt^3*ep/16)*chiK*lenEdge*(square(kappa3)+square(dt))*square((g-u))+(dt^3*ep/16)*chiK*dt^2*lenEdge*square((-N.y*(dxg-dx(u))+N.x*(dyg-dy(u)))));
         
	


int i=100;
real[int] H1b(i), h(i),L21(i),H121(i),toterr(i),dfu(i),dfsig(i),dfsig1(i),totdf(i),efficiency(i);
for(i=10;i<100;i=i+10){
    t=t+dt;
    mesh Th1=square(i,i);
    h[i] =Th1.hmax;
    fespace Vh2(Th1,P1);
    Vh2 u1old,v1old;
    solve Poisson1(u1old,v1old)=
      int2d(Th1)(0.01*(dx(u1old)*dx(v1old)+dy(u1old)*dy(v1old)))
      +int2d(Th1)((b1*dx(u1old)+b2*dy(u1old))*v1old)
      +int2d(Th1)(c*u1old*v1old)
      -int2d(Th1)(f*v1old)
      +on(1,2,3,4,u1old=g);
    fespace Vh3(Th1,P2);
    Vh3 v1,u1,error1,error2;
    Vh3 un1,up1;
    un1=u1old;
    fespace Ph(Th1,P1);
    Ph eff;
    fespace Rh1(Th1,RT1);
    Rh1 [sigma11,sigma21];
    Rh1 [sigman11,sigman21];
    Rh1 [tau11,tau21];
    macro grad(u1) [dx(u1),dy(u1)]//
    macro sigmah[sigma11,sigma21]//
    macro sigmanh[sigman11,sigman21]//
    macro tauh[tau11,tau21]//
    macro divsi(sigmah)[dx(sigma11)+dy(sigma21)]//
    macro divta(tauh)[dx(tau11)+dy(tau21)]//
    solve ad1([sigma11,sigma21,u1],[tau11,tau21,v1])
               =int2d(Th1)(dt*(sigmah'*tauh)/ep)
               -int2d(Th1)(dt*u1*(dx(tau11)+dy(tau21)))
               +int2d(Th1)(dt*v1*(dx(sigma11)+dy(sigma21)))
               +int2d(Th1)((1+dt*c)*u1*v1)
               -int2d(Th1)(convect([b1,b2],-dt,un1)*v1)
               +int2d(Th1)(kappa1*dt*(sigmah'*grad(v1)/ep-(sigmah'*tauh)/ep^2+grad(u1)'*grad(v1)-tauh'*grad(u1)/ep))
               +int2d(Th1)(kappa2*(dt*divsi(sigmah)'*divta(tauh)+dx(tau11)*(u1+u1*dt*c)+dy(tau21)*(u1+u1*dt*c)))
               -int2d(Th1)(kappa2*(dx(tau11)*convect([b1,b2],-dt,un1)+dy(tau21)*convect([b1,b2],-dt,un1)))
               +int1d(Th1)(kappa3*u1*v1) // when c=0
               -int2d(Th1)(dt*f*v1)
               +int1d(Th1)(dt*g*(N.x*tau11+N.y*tau21))
               -int2d(Th1)(kappa2*f*dt*(dx(tau11)+dy(tau21)))
              -int1d(Th1)(kappa3*g*v1); // when c=0
    int n=20;
    real[int] L2(n),H11(n),err1(n),H1(n);
    sigmanh=sigmah;//initializing sigma^n-1 as sigma^1
    
    
    un1=u1;
    for(n=1;n<20;n=n+1){
       
       ad1;
       error1=u1-un1;// So, here u^n=u^2 from the second iteration and u^n-1=u^1
       L2[n]=sqrt(int2d(Th1)(error1^2));
       H1[n]=sqrt(int2d(Th1)((error1)^2)+int2d(Th1)((dx(u1)-dx(un1))^2)+int2d(Th1)((dy(u1)-dy(un1))^2));
       H11[n]=sqrt(int2d(Th1)((sigman11-sigma11)^2)+int2d(Th1)((sigman21-sigma21)^2)+int2d(Th1)((dx(sigman11)-dx(sigma11)+dy(sigman21)-dy(sigma21))^2));
       //H11[n]=sqrt(int2d(Th)((-ep*dx(un1)-sigma11)^2)+int2d(Th)((-ep*dy(un1)-sigma21)^2)+int2d(Th)((f-b1*dx(un1)+c*u1-dx(sigma11))^2)+int2d(Th)((f-b2*dy(un1)+c*u1-dy(sigma21))^2));
       //H11[n]=sqrt(int2d(Th1)((-ep*dx(u1)-sigma11)^2)+int2d(Th1)((-ep*dy(u1)-sigma21)^2)+int2d(Th1)((-ep*dxx(u1)-dx(sigma11)-ep*dyy(u1)-dy(sigma21))^2));
       err1[n]=sqrt(H1[n]^2+H11[n]^2);
       cout<<n<<"tot err for ith mesh ="<<err1[n]<<endl;
       if (err1[n]<=7.21)
        {
       break;
       }
       un1=u1; //Swapping values of u^n-1 with u^n
       sigmanh=sigmah; //Swapping values of u^n-1 with u^n
       
       }
  
    
    error2=u-u1;// finding err 
    L21[i]=sqrt(int2d(Th)(error2^2));
    H1b[i]=sqrt(int2d(Th)((error2)^2)+int2d(Th)((dx(u)-dx(u1))^2)+int2d(Th)((dy(u)-dy(u1))^2));
    H121[i]=sqrt(int2d(Th)((sigma1-sigma11)^2)+int2d(Th)((sigma2-sigma21)^2)+int2d(Th1)((dx(sigma1)-dx(sigma11)+dy(sigma2)-dy(sigma21))^2));
    //H121[i]=sqrt(int2d(Th)((-ep*dx(u)-sigma11)^2)+int2d(Th)((-ep*dy(u)-sigma21)^2)+int2d(Th)((dx(sigma1)-dx(sigma11)+dy(sigma2)-dy(sigma21))^2));
    //H121[i]=sqrt(int2d(Th)((-ep*dx(u)-sigma11)^2)+int2d(Th)((-ep*dy(u)-sigma21)^2)+int2d(Th)((f-b1*dx(u)+c*u-dx(sigma11))^2)+int2d(Th)((f-b2*dy(u)+c*u-dy(sigma21))^2));
    toterr[i]=sqrt(H1b[i]^2+H121[i]^2);
    dfu[i]=u1.n;
    dfsig[i]=sigma11.n;
    dfsig1[i]=sigma11.n;
    totdf[i]=dfu[i]+dfsig[i];
   
    
    cout <<"i="<<i<<",L2 norm ="<<L21[i]<<endl;
    cout <<"i="<<i<<",H1 norm="<<H1b[i]<<endl;
    cout << "i="<<i<<",tot error="<<toterr[i]<<endl;
    cout << "i="<<i<<",H1 div norm sigma="<<H121[i]<<endl;
    cout << "i="<<i<<",Degrees of freedom u="<<dfu[i]<<endl;
    cout << "i="<<i<<",Degrees of freedom sigma="<<dfsig[i]<<endl;
    cout << "i="<<i<<",Degrees of freedom sigma="<<dfsig1[i]<<endl;
    cout << "i="<<i<<",Degrees of freedom tot="<<totdf[i]<<endl;
    eff[]=indicator2(0,Ph);
    efficiency[i]=eff[].sum/toterr[i];
    cout<<"Estimator"<<eff[].sum<<endl;
    cout<<"Efficiency"<<sqrt(efficiency[i])<<endl;
    cout << "i="<<i<<",mesh size="<<h[i]<<endl;
    plot(u1, wait=1, cmm="Final concentration", value=1, ps="Final concentration.eps");
    
    Vh1 gg=u;
    plot(gg, wait=1, cmm="Exact concentration", value=1, ps="Exact concentration.eps");
    
    plot([sigma11,sigma21], wait=1, cmm="Final flux", value=1, ps="Final flux.eps");
    
    Vh1 dxgg = - ep * dx(gg), dygg = - ep * dy(gg);
    plot([dxgg,dygg],wait=1, cmm="Exact flux", value=1, ps="Exact flux.eps");
}



for (int i=20;i<100;i=i+10){
cout << "rate of tot err="<<log(toterr[i-10]/toterr[i])/log(h[i-10]/h[i]) << endl;
}
for (int i=20;i<100;i=i+10){
cout << "mesh size="<< h[i] << endl;
}
for (int i=20;i<100;i=i+10){
cout << "tot err="<< toterr[i] << endl;
}
for (int i=20;i<100;i=i+10){
cout << " L2 rate of convergence ="<<log(L21[i-10]/L21[i])/log(h[i-10]/h[i]) << endl;
}
for (int i=20;i<100;i=i+10){
cout << " H1 rate of convergence  ="<<log(H1b[i-10]/H1b[i])/log(h[i-10]/h[i]) << endl;
}
for (int i=20;i<100;i=i+10){
cout << "H div rate of convergence ="<<log(H121[i-10]/H121[i])/log(h[i-10]/h[i]) << endl;
}

